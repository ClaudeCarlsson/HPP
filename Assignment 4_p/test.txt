#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "graphics.h"

#define EPSILON_ZERO 0.001

typedef struct
{
    int N, nsteps, graphics;
    double delta_t, G;
    const char *filename;
} InputData;

typedef struct
{
    double *x_y_m, *vx_vy, *brightness;
} Particle;

typedef struct
{
    double x, y;
} Position;

typedef struct
{
    double x, y, abs_eps_3pow;
} Distance;

typedef struct
{
    double x, y;
} Force;

InputData get_inputs(const char *argv[])
{
    InputData input;
    input.N = atoi(argv[1]);
    input.filename = argv[2];
    input.nsteps = atoi(argv[3]);
    input.delta_t = atof(argv[4]);
    input.graphics = atoi(argv[5]);
    input.G = (double)100 / input.N;
    return input;
}

Particle *load_particles(const InputData input)
{
    Particle *p = malloc(sizeof(Particle));

    p->x_y_m = (double *)malloc(3 * input.N * sizeof(double));
    p->vx_vy = (double *)malloc(2 * input.N * sizeof(double));
    p->brightness = (double *)malloc(1 * input.N * sizeof(double));

    FILE *file = fopen(input.filename, "rb");
    if (!file)
    {
        printf("Error in load_particles, couldn't open file: %s\n", input.filename);
        free(p);
        exit(-1);
    }

    for (int i = 0; i < input.N; i++)
    {
        if (
            !fread(&p->x_y_m[i * 3], sizeof(double), 3, file) || !fread(&p->vx_vy[i * 2], sizeof(double), 2, file) || !fread(&p->brightness[i], sizeof(double), 1, file))
        {
            printf("Error in load_particles, couldn't open file: %s\n", input.filename);
            free(p);
            exit(-1);
        }
    }

    fclose(file);

    return p;
}

int check_input_count(const int argc)
{
    if (argc == 6)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

void initialize_graphics()
{
    int windowWidth = 800;
    char windowName[10] = "Simulation";
    InitializeGraphics(windowName, windowWidth, windowWidth);
    SetCAxes(0, 1);
}

void draw_particles(double *p_x_y_m, double *p_vx_vy, const int N, const float c_rad, const float c_col, const float L, const float W)
{
    ClearScreen();
    for (int i = 0; i < N; i++)
    {
        DrawCircle(p_x_y_m[i * 3], p_x_y_m[i * 3 + 1], L, W, c_rad, c_col);
    }
    Refresh();
}

void update_particles(double *p_x_y_m, double *p_vx_vy, const InputData input, double **d, double **d_3pow, Position *pos, Distance r, Force f)
{
#pragma omp parallel for
    for (int i = 0; i < input.N; i++)
    {
        for (int j = i + 1; j < input.N; j++)
        {

            d[i][j] = sqrt((p_x_y_m[i * 3] - p_x_y_m[j * 3]) * (p_x_y_m[i * 3] - p_x_y_m[j * 3]) + (p_x_y_m[i * 3 + 1] - p_x_y_m[j * 3 + 1]) * (p_x_y_m[i * 3 + 1] - p_x_y_m[j * 3 + 1]));
            d[j][i] = d[i][j];
            d_3pow[i][j] = 1 / ((d[i][j] + EPSILON_ZERO) * (d[i][j] + EPSILON_ZERO) * (d[i][j] + EPSILON_ZERO));
            d_3pow[j][i] = d_3pow[i][j];
        }
    }

#pragma omp parallel for private(f, r)
    for (int i = 0; i < input.N; i++)
    {
        f.x = 0;
        f.y = 0;
        for (int j = 0; j < input.N; j++)
        {
            if (i == j)
            {
                continue;
            }
            r.x = p_x_y_m[i * 3] - p_x_y_m[j * 3];
            r.y = p_x_y_m[i * 3 + 1] - p_x_y_m[j * 3 + 1];

            f.x += p_x_y_m[j * 3 + 2] * d_3pow[i][j] * r.x;
            f.y += p_x_y_m[j * 3 + 2] * d_3pow[i][j] * r.y;
        }
        // Velocity
        p_vx_vy[i * 2] += input.delta_t * -input.G * f.x;
        p_vx_vy[i * 2 + 1] += input.delta_t * -input.G * f.y;

        // Position
        pos[i].x = p_x_y_m[i * 3] + input.delta_t * p_vx_vy[i * 2];
        pos[i].y = p_x_y_m[i * 3 + 1] + input.delta_t * p_vx_vy[i * 2 + 1];
    }

    for (int i = 0; i < input.N; i++)
    {
        // Update particle position per step
        p_x_y_m[i * 3] = pos[i].x;
        p_x_y_m[i * 3 + 1] = pos[i].y;
    }
}

void start_system(Particle *p, const InputData input)
{
    const float c_rad = 0.005, c_col = 0;
    const int L = 1, W = 1;

    Position *pos = malloc(input.N * sizeof(Position));
    Force f = {0, 0};
    Distance r = {0, 0};

    double *p_x_y_m = p->x_y_m;
    double *p_vx_vy = p->vx_vy;

    double **d = (double **)malloc(input.N * sizeof(double *));
    for (int i = 0; i < input.N; i++)
    {
        d[i] = (double *)malloc(input.N * sizeof(double));
    }

    double **d_3pow = (double **)malloc(input.N * sizeof(double *));
    for (int i = 0; i < input.N; i++)
    {
        d_3pow[i] = (double *)malloc(input.N * sizeof(double));
    }

    for (int i = 0; i < input.nsteps; i++)
    {
        if (input.graphics)
        {
            draw_particles(p->x_y_m, p->vx_vy, input.N, c_rad, c_col, L, W);
        }

#pragma omp parallel for
        for (int i = 0; i < input.N; i++)
        {
            for (int j = i + 1; j < input.N; j++)
            {

                d[i][j] = sqrt((p_x_y_m[i * 3] - p_x_y_m[j * 3]) * (p_x_y_m[i * 3] - p_x_y_m[j * 3]) + (p_x_y_m[i * 3 + 1] - p_x_y_m[j * 3 + 1]) * (p_x_y_m[i * 3 + 1] - p_x_y_m[j * 3 + 1]));
                d[j][i] = d[i][j];
                d_3pow[i][j] = 1 / ((d[i][j] + EPSILON_ZERO) * (d[i][j] + EPSILON_ZERO) * (d[i][j] + EPSILON_ZERO));
                d_3pow[j][i] = d_3pow[i][j];
            }
        }

#pragma omp parallel for private(f, r)
        for (int i = 0; i < input.N; i++)
        {
            f.x = 0;
            f.y = 0;
            for (int j = 0; j < input.N; j++)
            {
                if (i == j)
                {
                    continue;
                }
                r.x = p_x_y_m[i * 3] - p_x_y_m[j * 3];
                r.y = p_x_y_m[i * 3 + 1] - p_x_y_m[j * 3 + 1];

                f.x += p_x_y_m[j * 3 + 2] * d_3pow[i][j] * r.x;
                f.y += p_x_y_m[j * 3 + 2] * d_3pow[i][j] * r.y;
            }
            // Velocity
            p_vx_vy[i * 2] += input.delta_t * -input.G * f.x;
            p_vx_vy[i * 2 + 1] += input.delta_t * -input.G * f.y;

            // Position
            pos[i].x = p_x_y_m[i * 3] + input.delta_t * p_vx_vy[i * 2];
            pos[i].y = p_x_y_m[i * 3 + 1] + input.delta_t * p_vx_vy[i * 2 + 1];
        }

        for (int i = 0; i < input.N; i++)
        {
            // Update particle position per step
            p_x_y_m[i * 3] = pos[i].x;
            p_x_y_m[i * 3 + 1] = pos[i].y;
        }
    }

    free(pos);

    for (int i = 0; i < input.N; i++)
    {
        free(d[i]);
    }

    free(d);
}

void write_to_output_file(const Particle *p, const int N)
{
    FILE *output = fopen("result.gal", "wb");
    for (int i = 0; i < N; i++)
    {
        fwrite(&p->x_y_m[3 * i], sizeof(double), 3, output);
        fwrite(&p->vx_vy[2 * i], sizeof(double), 2, output);
        fwrite(&p->brightness[i], sizeof(double), 1, output);
    }
    fclose(output);
}

void print_particle(const Particle *p, int N)
{
    for (int i = 0; i < N; i++)
    {
        printf("# %2.0d | x: %5.2lf, y: %5.2lf, mass: %5.2lf, vx: %5.2lf, vy: %5.2lf, brightness: %5.2lf\n",
               (i + 1), p->x_y_m[i * 3], p->x_y_m[i * 3 + 1], p->x_y_m[i * 3 + 2], p->vx_vy[i * 2], p->vx_vy[i * 2 + 1], p->brightness[i]);
    }
}

int main(int argc, char const *argv[])
{
    // Checks input data
    if (!check_input_count(argc))
    {
        printf("Usage: %s  <N> <filename> <nsteps> <delta_t> <graphics> \n", argv[0]);
        return -1;
    }

    InputData input = get_inputs(argv);

    // Load particles
    Particle *particles = load_particles(input);
    if (particles == NULL)
    {
        printf("Error loading the particles");
        return -1;
    }

    // Check graphics
    if (input.graphics)
    {
        initialize_graphics();
    }
    // Print particles data
    // print_particle(particles, input.N);

    // Start system
    start_system(particles, input);

    // Write result to file
    write_to_output_file(particles, input.N);

    // Quit graphics if enabled
    if (input.graphics)
    {
        FlushDisplay();
        CloseDisplay();
    }
    free(particles->x_y_m);
    free(particles->vx_vy);
    free(particles->brightness);
    free(particles);

    return 0;
}
